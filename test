import pygame
import math

# Initialize Pygame
pygame.init()

# Screen dimensions
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Elliptical Pocket Example")

# Clock for controlling the frame rate
clock = pygame.time.Clock()

# Ellipse (pocket) properties
ellipse = {
    "x": WIDTH // 2,  # Center of the ellipse
    "y": HEIGHT // 2,
    "a": 150,  # Horizontal radius
    "b": 100,  # Vertical radius
    "color": (0, 0, 0),  # Black outline
}

# Ball properties
ball = {
    "x": WIDTH // 4,  # Starting position
    "y": HEIGHT // 2,
    "radius": 15,
    "color": (255, 0, 0),  # Red color
    "velocity_x": 3,  # Horizontal velocity
    "velocity_y": 2,  # Vertical velocity
    "is_in_pocket": False,  # Pocket state
}

# Function to check if ball is inside the ellipse
def is_ball_in_pocket(ball, ellipse):
    dx = ball["x"] - ellipse["x"]
    dy = ball["y"] - ellipse["y"]
    distance = (dx**2) / (ellipse["a"]**2) + (dy**2) / (ellipse["b"]**2)
    return distance <= 1

# Function to check collision with ellipse boundary
def check_collision_with_ellipse(ball, ellipse):
    dx = ball["x"] - ellipse["x"]
    dy = ball["y"] - ellipse["y"]
    distance = (dx**2) / (ellipse["a"]**2) + (dy**2) / (ellipse["b"]**2)
    return math.isclose(distance, 1, abs_tol=0.01)

# Function to reflect ball on collision with ellipse
def reflect_ball(ball, ellipse):
    dx = ball["x"] - ellipse["x"]
    dy = ball["y"] - ellipse["y"]
    magnitude = math.sqrt(dx**2 + dy**2)
    if magnitude == 0:
        return  # Avoid division by zero
    # Normal vector at collision point
    normal_x = dx / magnitude
    normal_y = dy / magnitude
    # Reflect velocity
    dot_product = ball["velocity_x"] * normal_x + ball["velocity_y"] * normal_y
    ball["velocity_x"] -= 2 * dot_product * normal_x
    ball["velocity_y"] -= 2 * dot_product * normal_y

# Game loop
running = True
while running:
    screen.fill((50, 150, 50))  # Green background for table

    # Event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Update ball position if it's not in the pocket
    if not ball["is_in_pocket"]:
        ball["x"] += ball["velocity_x"]
        ball["y"] += ball["velocity_y"]

        # Check for collision with the edge of the ellipse
        if check_collision_with_ellipse(ball, ellipse):
            reflect_ball(ball, ellipse)

        # Check if the ball is inside the pocket
        if is_ball_in_pocket(ball, ellipse):
            print("Ball is in pocket")
            ball["is_in_pocket"] = True
            ball["velocity_x"] = 0
            ball["velocity_y"] = 0
            ball["x"] = ellipse["x"]  # Center ball in pocket
            ball["y"] = ellipse["y"]

    # Draw the ellipse
    pygame.draw.ellipse(
        screen,
        ellipse["color"],
        (ellipse["x"] - ellipse["a"], ellipse["y"] - ellipse["b"], 2 * ellipse["a"], 2 * ellipse["b"]),
        2,
    )

    # Draw the ball
    pygame.draw.circle(screen, ball["color"], (int(ball["x"]), int(ball["y"])), ball["radius"])

    # Update the screen
    pygame.display.flip()
    clock.tick(60)  # Limit FPS

pygame.quit()
